/**
 * @fileoverview Firestore Security Rules for SportConnect.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-layered security model, combining path-based ownership,
 * resource-based access control lists, and strict validation of relational integrity.
 * The primary goals are to protect user data, ensure proper authorization for activity
 * management, and prevent data corruption.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the user themselves.
 * - /activities/{activityId}: Stores activity requests, with access control based on
 *   the organizer and accepted participants.
 * - /activities/{activityId}/responses/{responseId}: Stores responses to activities,
 *   protected by the activity's access control.
 * - /activities/{activityId}/messages/{messageId}: Stores chat messages related to activities,
 *   with access control based on activity participation.
 *
 * Key Security Decisions:
 * - User profiles are strictly private, accessible only to the owning user.
 * - Activities are accessible to the organizer and accepted participants.
 * - Listing of user profiles is disallowed to prevent unauthorized data scraping.
 * - Data validation focuses on relational integrity and authorization-critical fields.
 *
 * Denormalization for Authorization:
 * - The `Activity` document includes the `organizerId` to easily check activity ownership.
 * - The `Activity` document includes the `participantIds` to authorize access to the chat messages.
 * - The `ChatMessage` includes the `activityId`, `senderId` and `participantIds` to authorize reading.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles, ensuring only the user can access their own data.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user_abc' can create their profile.
     *   - request.auth.uid: 'user_abc'
     *   - request.resource.data.id: 'user_abc'
     * @allow (get, update, delete) - User with ID 'user_abc' can read/write their profile.
     *   - request.auth.uid: 'user_abc'
     * @deny (create) - User with ID 'user_def' cannot create a profile for 'user_abc'.
     *   - request.auth.uid: 'user_def'
     *   - request.resource.data.id: 'user_abc'
     * @deny (get, update, delete) - User with ID 'user_def' cannot read/write 'user_abc''s profile.
     *   - request.auth.uid: 'user_def'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      // isOwner(userId)	User with ID 'user_abc' can read/write their profile.	request.auth.uid: 'user_abc'
      //User with ID 'user_def' cannot read/write 'user_abc''s profile.	request.auth.uid: 'user_def'
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.id == request.resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages access to activity requests, allowing the organizer and accepted participants to read and modify.
     * @path /activities/{activityId}
     * @allow (get, list) - Any signed-in user can view activities.
     *   - request.auth.uid: 'any_user'
     * @allow (create) - Organizer with ID 'user_abc' can create an activity.
     *   - request.auth.uid: 'user_abc'
     *   - request.resource.data.organizerId: 'user_abc'
     * @allow (update, delete) - Organizer with ID 'user_abc' can update/delete the activity.
     *   - request.auth.uid: 'user_abc'
     *   - resource.data.organizerId: 'user_abc'
     * @deny (create) - User with ID 'user_def' cannot create an activity for 'user_abc'.
     *   - request.auth.uid: 'user_def'
     *   - request.resource.data.organizerId: 'user_abc'
     * @deny (update, delete) - User with ID 'user_def' cannot update/delete 'user_abc''s activity.
     *   - request.auth.uid: 'user_def'
     *   - resource.data.organizerId: 'user_abc'
     * @principle Restricts writes to the activity organizer.
     */
    match /activities/{activityId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.organizerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwnerOfActivity(activityId, request.auth.uid);
      allow delete: if isSignedIn() && isExistingOwnerOfActivity(activityId, request.auth.uid);
    }

    /**
     * @description Controls access to activity responses, restricting it to the respondent.
     * @path /activities/{activityId}/responses/{responseId}
     * @allow (get, list) - Any signed-in user can view activity responses.
     *   - request.auth.uid: 'any_user'
     * @allow (create) - User with ID 'user_abc' can create a response to activity 'activity_123'.
     *   - request.auth.uid: 'user_abc'
     *   - request.resource.data.respondentId: 'user_abc'
     *   - request.resource.data.activityId: 'activity_123'
     * @allow (update, delete) - User with ID 'user_abc' can update/delete their response.
     *   - request.auth.uid: 'user_abc'
     *   - resource.data.respondentId: 'user_abc'
     *   - resource.data.activityId: 'activity_123'
     * @deny (create) - User with ID 'user_def' cannot create a response for 'user_abc'.
     *   - request.auth.uid: 'user_def'
     *   - request.resource.data.respondentId: 'user_abc'
     * @deny (update, delete) - User with ID 'user_def' cannot update/delete 'user_abc''s response.
     *   - request.auth.uid: 'user_def'
     *   - resource.data.respondentId: 'user_abc'
     * @principle Enforces ownership of activity responses.
     */
    match /activities/{activityId}/responses/{responseId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.respondentId == request.auth.uid && request.resource.data.activityId == activityId;
      allow update: if isSignedIn() && isExistingOwnerOfActivityResponse(activityId, responseId, request.auth.uid);
      allow delete: if isSignedIn() && isExistingOwnerOfActivityResponse(activityId, responseId, request.auth.uid);
    }

    /**
     * @description Manages chat messages within an activity, allowing only accepted participants to read and write.
     * @path /activities/{activityId}/messages/{messageId}
     * @allow (get, list) - Accepted participant 'user_abc' can view chat messages.
     *   - request.auth.uid: 'user_abc'
     *   - Activity.participantIds contains 'user_abc'
     * @allow (create) - Accepted participant 'user_abc' can create chat messages.
     *   - request.auth.uid: 'user_abc'
     *   - request.resource.data.senderId: 'user_abc'
     * @allow (update, delete) - Accepted participant 'user_abc' can update/delete their chat messages.
     *   - request.auth.uid: 'user_abc'
     *   - resource.data.senderId: 'user_abc'
     * @deny (get, list) - Non-participant 'user_def' cannot view chat messages.
     *   - request.auth.uid: 'user_def'
     *   - Activity.participantIds does not contain 'user_def'
     * @deny (create) - Non-participant 'user_def' cannot create chat messages.
     *   - request.auth.uid: 'user_def'
     *   - request.resource.data.senderId: 'user_def'
     * @principle Restricts chat access to accepted activity participants.
     */
    match /activities/{activityId}/messages/{messageId} {
      allow get, list: if isSignedIn() && isAcceptedParticipant(activityId, request.auth.uid);
      allow create: if isSignedIn() && request.resource.data.senderId == request.auth.uid && isAcceptedParticipant(activityId, request.auth.uid);
      allow update: if isSignedIn() && isExistingOwnerOfChatMessage(activityId, messageId, request.auth.uid);
      allow delete: if isSignedIn() && isExistingOwnerOfChatMessage(activityId, messageId, request.auth.uid);
    }

    // --- Helper Functions ---

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isOwnerOfActivity(activityId, userId) {
        return get(/databases/$(database)/documents/activities/$(activityId)).data.organizerId == userId;
    }

    function isExistingOwnerOfActivity(activityId, userId) {
      return isOwnerOfActivity(activityId, userId) && resource != null;
    }

    function isOwnerOfActivityResponse(activityId, responseId, userId) {
      return get(/databases/$(database)/documents/activities/$(activityId)/responses/$(responseId)).data.respondentId == userId;
    }

    function isExistingOwnerOfActivityResponse(activityId, responseId, userId) {
      return isOwnerOfActivityResponse(activityId, responseId, userId) && resource != null;
    }

    function isAcceptedParticipant(activityId, userId) {
      return userId in get(/databases/$(database)/documents/activities/$(activityId)).data.participantIds;
    }

     function isOwnerOfChatMessage(activityId, messageId, userId) {
      return get(/databases/$(database)/documents/activities/$(activityId)/messages/$(messageId)).data.senderId == userId;
    }

    function isExistingOwnerOfChatMessage(activityId, messageId, userId) {
      return isOwnerOfChatMessage(activityId,messageId, userId) && resource != null;
    }
  }
}
